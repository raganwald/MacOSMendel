/** * * A MirrorPublisher is a PublishStrategy which consists * of writing the member's stream representation to a file * in a mirror directory. * * This simple version writes the file when it is first created * and again when it is updated. * * A complete rewrite closely synchronizing the URL and update * methods is in order. ***/package COM.codestorm.publisher;import COM.codestorm.mendel.*;import COM.codestorm.builders.*;import java.util.*;import java.io.*;import COM.objectspace.jgl.*;public class MirrorPublisher extends AbstractSuperPublisher implements Observer {protected static MissingMember missingRoot = null;static {	try {		missingRoot = new MissingMember(Root.instance());	}	catch (MendelException me) {}}protected AbstractTextMember myURL = null;protected File myFile = null;public MirrorPublisher (AbstractMember aMember) {	super(aMember);	if ( aMember instanceof Observable ) {		((Observable) aMember).addObserver(this);		this.update((Observable) aMember,null);	}}public void update(Observable o, Object arg) {	try {		update();	}	catch (MendelException me) {		System.err.println(me.getMessage());	}}public AbstractTextMember getURLText () throws MendelException {	if ( myURL == null )		this.update();	return myURL;}protected String getStringName () throws MendelException {	String outName;	String memberMimeType = this.getMIMEType();	if ( memberMimeType == null )		throw new PublisherException("No MIME Type for this Mirror Published Member");	String memberName = myMember.getProperty(AbstractMember.keyName);	int dotIndex = memberName.lastIndexOf(".");	if ( dotIndex < 0 )		outName = memberName + Defaults.getFileSuffix(memberMimeType);	else {		String actualSuffix = memberName.substring(dotIndex);		String indicatedMIMEType = Defaults.getMIMEType(actualSuffix);		if ( indicatedMIMEType == null )			outName = memberName.substring(0,dotIndex) + Defaults.getFileSuffix(memberMimeType);		else if ( memberMimeType.equals(Defaults.getProperty(Defaults.kMIMEHTML)) ) // HTML -- probably processing this			outName = memberName.substring(0,dotIndex) + Defaults.getFileSuffix(memberMimeType);		else if ( !(indicatedMIMEType.equalsIgnoreCase(memberMimeType)) )			outName = memberName.substring(0,dotIndex) + Defaults.getFileSuffix(memberMimeType);		else outName = memberName;	}	return outName;}/** * * @return Sequence A list of intermediate, named containers ***/protected Sequence getContainerChain () throws MendelException {	AbstractMember iterMember = myMember;	Sequence containerChain = new SList();	do {		iterMember = iterMember.getStaticScope(MissingMember.Null);		if ( iterMember != null && !iterMember.getProperty(AbstractMember.keyName,"").equals("") )			containerChain.pushFront(iterMember);	} while ( iterMember != null );	return containerChain;}public void update () throws MendelException {	HTMLString urlText = new HTMLString(Defaults.getProperty(Defaults.kTopOutUrl), myMember);	StringBuffer outPath = new StringBuffer(Defaults.getProperty(Defaults.kTopOutDirectory) + File.separator);	Enumeration e = this.getContainerChain().elements();	while ( e.hasMoreElements() ) {		AbstractMember eachContainer = (AbstractMember) e.nextElement();		if ( !eachContainer.equals(Root.instance()) ) {			String eachContainerName = eachContainer.getProperty(AbstractMember.keyName);			urlText.append(Defaults.toURLString(eachContainerName) + Defaults.getProperty(Defaults.kURLSeparator));			outPath.append(eachContainerName + File.separator);		}	}	urlText.append(Defaults.toURLString(this.getStringName()));		String containerPath = outPath.toString();	String memberName = this.getStringName();	outPath.append(this.getStringName());	File mirrorFolder = new File(containerPath);	if ( !mirrorFolder.mkdirs() )		throw new PublisherException("Unable to create folder(s) "+containerPath);		myURL = urlText;	myFile = new File(outPath.toString());		try {		InputStream inStream = myMember.asMIMEStream();		myFile.delete();		RandomAccessFile outFile = new RandomAccessFile( myFile.getPath(), "rw" );		int bufSize = 2048;		byte[] buf = new byte[bufSize];		int actualBytes = 0;		try {			do {				if ( (actualBytes = inStream.read(buf)) > 0 )					outFile.write(buf, 0, actualBytes);			} while (actualBytes > 0);					}		catch (IOException ioe) {			throw new PublisherException("Failed to mirror "+memberName+" because "+ioe.toString());		}		finally {			inStream.close();			outFile.close();		}	}	catch (IOException ioe) {		throw new PublisherException("Failed to mirror "+memberName+" because "+ioe.toString());	}}public InputStream asMIMEStream () throws MendelException {	if ( myFile == null )		this.update();	try {		return new FileInputStream(myFile);	}	catch (FileNotFoundException fnfe) {		throw new PublisherException(fnfe.getMessage());	}}}