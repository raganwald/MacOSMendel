/** * Copyright (c) 1996, 1997 Codestorm Inc. All rights reserved. * * @author Reginald Braithwaite-Lee ***/package COM.codestorm.mendel;import COM.codestorm.thunks.*;import java.io.IOException;import COM.codestorm.publisher.*;public final class Symbol extends AbstractSuperAtomicMember {protected String stringRep;private MissingThrower throwMe;private final static String kThisName = Defaults.getProperty(Defaults.kThisName);private final static String kContainerName = Defaults.getProperty(Defaults.kContainerName);private final static String kParentName = Defaults.getProperty(Defaults.kParentName);/** * * Symbols are constants as themselves, but since they override * evaluate, they can be used as thunks for lookup purposes. * <P> * A future enhancement will be to enhance evaluateOnce to scatter * placeholders so that we can detect overrides. ***/public Symbol (String s) throws MendelException {//	super(FixedVariable.CONSTANT);	stringRep = s;	throwMe = new MissingThrower(new MemberNotFoundException(s));}public Symbol (AbstractMember aam) throws MendelException {	this(aam.toString());}public AbstractMember evaluate (AbstractMemberContainer scope ) throws MendelException {			AbstractMemberContainer testContainer = scope;	AbstractMember foundMember;		if ( stringRep.equals(kThisName) )		return scope;	else if ( stringRep.equals(kContainerName) )		return scope.getStaticScope(MissingThrower.NoContainerThrower);	else if ( stringRep.equals(kParentName) )		return scope.getParent(MissingThrower.NoParentThrower);	else do {		foundMember = evaluateOnce(testContainer);		if ( foundMember != null )			return foundMember;		else if ( testContainer.getProperty(AbstractMember.keyName,"").equals(stringRep) ) // stringreps should never be empty			return testContainer;		else testContainer = testContainer.getStaticScope(throwMe);	} while (true);}private AbstractMember evaluateOnce (AbstractMemberContainer scope) throws MendelException {	AbstractMember resolved = scope.getMember(stringRep,MissingMember.Null);	if (resolved == null ) {		AbstractMemberContainer scopeParent = (AbstractMemberContainer) scope.getParent(MissingMember.Null);		if ( scopeParent == null )			return null;		else return evaluateOnce(scopeParent);	}	else return resolved;}public String toString() {	return stringRep.toString();}public boolean equals (Object obj) {	if ( obj instanceof Symbol )		return obj.toString().equals(stringRep);	else if ( obj instanceof String )		return obj.equals(stringRep);	else if ( obj instanceof AbstractMember ) {		try {			return this.equals(((AbstractMember) obj).yourself());		}		catch (MendelException me) {			return false;		}	}	else return false;}}