/** * Copyright (c) 1996, 1997 Codestorm Inc. All rights reserved. ***/package COM.codestorm.thunks;import java.util.*;import java.io.*;import COM.codestorm.mendel.*;publicfinal class ThunkChainEnvelope implements AbstractThunk {protected Vector chainLetter;public String sval = null;private AbstractMemberContainer origStaticMember;private ThunkChainEnvelope () {	chainLetter = new Vector();}private ThunkChainEnvelope (ThunkTokenizer t, AbstractMemberContainer staticMember) throws IOException, MendelException {	this();	origStaticMember = staticMember;	this.parse(t);	if ( chainLetter.isEmpty() ) throw new IOException("AbstractThunk requires path");}public static AbstractThunk valueOf (String s) throws IOException, MendelException {	ThunkChainEnvelope envelopeThunk = new ThunkChainEnvelope(s);	if ( envelopeThunk.chainLetter.size() > 1 )		return envelopeThunk;	else {		AbstractThunk letterThunk = (AbstractThunk) envelopeThunk.chainLetter.elementAt(0);		if ( letterThunk instanceof LookupNameThunk )			return new Symbol(letterThunk.toString());		else return letterThunk;	}}public ThunkChainEnvelope (AbstractMember memberToProxy) {	this(new ProxyThunk(memberToProxy));}public ThunkChainEnvelope (AbstractThunk t) {	this();	this.append(t);}public ThunkChainEnvelope (String s) throws IOException, MendelException {	this(new ThunkTokenizer(s), null);	sval = s;}public ThunkChainEnvelope (String s, AbstractMemberContainer staticMember) throws IOException, MendelException {	this(new ThunkTokenizer(s), staticMember);	sval = s;}private void parse(ThunkTokenizer t) throws IOException, MendelException {	boolean firstToken = true;		while ( t.nextToken() != ThunkTokenizer.TT_EOF ) {		String token = t.currentWord();				if (token.equals(AbstractThunk.parentSymbol)) {			chainLetter.addElement(new ParentThunk());		} else if (token.equals(AbstractThunk.containerSymbol)) {			chainLetter.addElement(new ContainerThunk());		} else if (token.equals(AbstractThunk.thisSymbol)) {			chainLetter.addElement(new ThisThunk());		} else if (t.sval != null) {			if (!firstToken) {				chainLetter.addElement(new MemberByNameThunk(t.sval));			} else if ( t.sval.startsWith(FileThunk.fileIdentifier) ) {				this.addFileThunk(t.sval.substring(FileThunk.fileIdentifier.length()));			} else if ( t.sval.startsWith(ClassThunk.classIdentifier) ) {				chainLetter.addElement(new ClassThunk(t.sval.substring(ClassThunk.classIdentifier.length())));			} else if ( t.sval.indexOf(File.separator) >= 0 ) {				this.addFileThunk(t.sval);			} else if (origStaticMember == null)				chainLetter.addElement(new LookupNameThunk(t.sval));			else chainLetter.addElement(new MemoizedNameThunk(t.sval, origStaticMember));		}		firstToken = false;	}}private void addFileThunk (String newPath) throws MendelException {	chainLetter.addElement(new FileThunk(newPath));}public void append (AbstractThunk t) {	chainLetter.addElement(t);}public void addFirst (AbstractThunk t) {	chainLetter.insertElementAt(t,0);}public AbstractMember evaluate (AbstractMemberContainer scope) throws MendelException {	try {		AbstractMemberContainer newContext = scope;		AbstractMember resolved = null;		int z = chainLetter.size();		int z1 = z-1;		for ( int i = 0; i < z; i++ ) {			resolved = ((AbstractThunk) chainLetter.elementAt(i)).evaluate(newContext);			if ( i < z1 ) { // even more elements				try {					if ( resolved.yourself() instanceof AbstractMemberContainer )						newContext = (AbstractMemberContainer) resolved.yourself();					else return resolved;				}				catch (MemberNotFoundException mnfe) {					return resolved;				}			}		}		return resolved;	}	catch (MendelException me) {		System.err.println("Failed to evaluate "+sval+" in "+scope.debugString());		throw me;	}}public int size () throws MendelException {	return chainLetter.size();}public String toString() {	if ( sval != null )		return sval;	else if ( chainLetter.size() > 1 ) {		StringBuffer buf = new StringBuffer();		Enumeration e = chainLetter.elements();		while ( e.hasMoreElements() )			buf.append( e.nextElement().toString());		return buf.toString();	} else if ( chainLetter.size() == 1 )		return chainLetter.elementAt(0).toString();	else return "<EMPTY-THUNK-CHAIN-ENVELOPE>";}}