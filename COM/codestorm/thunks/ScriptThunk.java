/** * * @author Reginald Braithwaite-Lee ***/package COM.codestorm.thunks;import COM.codestorm.builders.*;import COM.codestorm.mendel.*;import COM.objectspace.jgl.*;import java.util.*;import java.io.*;import COM.codestorm.lambdas.*;public class ScriptThunk implements AbstractThunk {protected Sequence thunkSequence;public AbstractMember evaluate (AbstractMemberContainer scope) throws MendelException {	AbstractMember retValue = null;	Enumeration e = thunkSequence.elements();	//System.err.println(thunkSequence.size()+" elements to evaluate in ScriptThunk");	while ( e.hasMoreElements() ) {		AbstractThunk eachThunk = (AbstractThunk) e.nextElement();		retValue = eachThunk.evaluate(scope);	}	return retValue;}public final static char separatorOp = '/';public final static char memberOp = '.';public final static char openApply = '(';public final static char closeApply = ')';public final static char openLambda = '[';public final static char closeLambda = ']';public final static char footMark = '\'';public final static char inchMark = '\"';public final static char verticalBar = '|';public final static char collectionSuffix = '*';public final static String htmlEscape = "__HTML__";/** * builds a ScriptThunk from a mendelLISP expression. * * @param String	stringRep the LISP expression * @return The ScriptThunk * @exception MendelException a syntax error of some sort. ***/public ScriptThunk (String rawString, AbstractMemberContainer scope) throws MendelException {	Sequence esc = new SList();	thunkSequence = new SList();		String stringRep = processHTML(rawString,esc);		AbstractThunk eachThunk;	StreamTokenizer mlt =  getStreamTokenizer(stringRep);		while ( (eachThunk = NextMember(scope,mlt,esc)) != null ) {		if ( eachThunk.equals(String.valueOf(closeApply)) )			throw new MendelException("Unexpected ) in Lambda");		else if ( eachThunk.equals(String.valueOf(closeLambda)) )			throw new MendelException("Unexpected ] in Lambda");		else if ( eachThunk.equals(String.valueOf(verticalBar)) )			throw new MendelException("Unexpected | in Lambda");		else thunkSequence.pushBack(eachThunk);	}}public static AbstractMember getMethod (String rawString, AbstractMemberContainer scope) throws MendelException {	Frame methodScope = new Frame();	methodScope.setStaticScope(scope);	ScriptThunk theScript = new ScriptThunk(rawString,methodScope);	return theScript.evaluate(methodScope);	}public static String processHTML (String rawString, Sequence esc) throws MendelException {	String stringRep = new String(rawString);	String htmlTag;	// first,  locate and remove <HTML>É</HTML> segments	int nextStart = stringRep.indexOf(Defaults.openHTML);	int nextStop;		while ( nextStart >= 0 ) {		int balance = 1;		int cursor = stringRep.indexOf(Defaults.closeTag,nextStart + Defaults.openHTMLLength) + 1;		int contentStart = cursor;				if ( cursor <= nextStart )			throw new MendelException("<HTML> tag is unclosed!");				htmlTag = stringRep.substring(nextStart,cursor);				do {			int tempNextStart = stringRep.indexOf(Defaults.openHTML,cursor);			nextStop = stringRep.indexOf(Defaults.closeHTML,cursor);						if ( nextStop < 0 ) // no more stops??				throw new MendelException("<HTML> without matching </HTML>");			if ( tempNextStart < 0 ) { // there is no further start				--balance;				cursor = nextStop + Defaults.closeHTMLLength;			}			else if ( tempNextStart > nextStop ) { // next start is *after* next stop				--balance;				cursor = nextStop + Defaults.closeHTMLLength;			}			else {				++balance;				cursor = tempNextStart + Defaults.openHTMLLength;			}		} while ( balance > 0 );				esc.pushBack( stringRep.substring(nextStart,cursor) );				stringRep = stringRep.substring(0,nextStart)			+ " " + htmlEscape + " "			+ stringRep.substring(cursor);				nextStart = stringRep.indexOf(Defaults.openHTML);			}		return stringRep;}private static StreamTokenizer getStreamTokenizer (String stringRep) {	StreamTokenizer mlt = new StreamTokenizer(new StringBufferInputStream(stringRep));		mlt.wordChars(separatorOp,separatorOp);	mlt.wordChars(memberOp,memberOp);	mlt.wordChars('_','_');	mlt.wordChars(ScriptThunk.collectionSuffix,ScriptThunk.collectionSuffix);	mlt.wordChars('+','+');	mlt.wordChars('=','=');	mlt.wordChars('!','!');	mlt.wordChars('~','~');	mlt.wordChars('/', '/'); // path separators in various OS styles	mlt.wordChars('\\', '\\');	mlt.wordChars(':', ':');	mlt.wordChars('#', '#'); // name separator	mlt.wordChars('?', '?'); // name separator	mlt.ordinaryChar(openApply);	mlt.ordinaryChar(closeApply);	mlt.ordinaryChar(openLambda);	mlt.ordinaryChar(closeLambda);		return mlt;}/** * * @return the next member. recursive descent. * @exception MendelException some sort of syntax error ***/private static AbstractThunk NextMember		(AbstractMemberContainer scope, StreamTokenizer st, Sequence htmls) throws MendelException {	try {		int tokenType = st.nextToken();		switch (tokenType) {			case StreamTokenizer.TT_EOF:				return null;			case StreamTokenizer.TT_NUMBER:				return new ManufacturedMember(String.valueOf(st.nval));			case StreamTokenizer.TT_WORD:				if ( st.sval.equals(htmlEscape) )					return thunkForScope(new HTMLThunk((String) htmls.popFront()),scope);				else return ThunkChainEnvelope.valueOf(st.sval);			case footMark:			case inchMark:				return new ManufacturedMember(st.sval);			case closeApply:			case closeLambda:			case verticalBar:				return new Symbol(String.valueOf((char) tokenType));			case openApply:				// starting an apply				Sequence parameters = new Array();				AbstractThunk theNext; 				while ( !(theNext = NextMember(scope,st,htmls)).equals(String.valueOf(closeApply)) )					parameters.pushBack(theNext);				Apply newApply = new Apply(parameters);				return newApply;			case openLambda:				// starting a lambda expression				Sequence parameterList = new SList();				Sequence expressionList = new Array();				ScriptLambda newLambda = new ScriptLambda();				boolean expectPSE = true;				while (true) {					theNext = NextMember(null,st,htmls);					if ( theNext.equals(String.valueOf(verticalBar)) ) {						if ( expectPSE ) {							parameterList = new SList();							Enumeration e = expressionList.elements();							while ( e.hasMoreElements() ) {								Object obj = e.nextElement();								if ( obj instanceof Symbol )									parameterList.pushBack(obj.toString());								else throw new MendelException("parameter lists must be symbols, not \""+obj+"\"");							}							expressionList = new SList();							expectPSE = false;						}						else throw new MendelException("Unexpected second | in lambda");					}					else if ( 	theNext.equals(String.valueOf(closeLambda)) ) {						newLambda.setParameterList(parameterList);						newLambda.setExpressionList(expressionList);						newLambda.putProperty(AbstractMember.keyName, newLambda.toString());						return thunkForScope((AbstractMember) newLambda, scope);					}					else expressionList.pushBack(theNext);				}			default:				System.err.println(" operator " + (char) tokenType);				return null;		}	}	catch (IOException ioe) {		throw new MendelException("missing member or unclosed expression");	}}private static final AbstractThunk thunkForScope (AbstractMember member, AbstractMemberContainer scope) throws MendelException {	if ( scope != null )		member.setStaticScope(scope);	return member;}private static final AbstractThunk thunkForScope (AbstractThunk thunk, AbstractMemberContainer scope) throws MendelException {	if ( scope == null )		return new ThunkEnvelope(thunk);	else return new ThunkEnvelope(thunk,scope);}public String toString () {	StringBuffer buf = new StringBuffer("<SERVER> ");	Enumeration e = thunkSequence.elements();	while ( e.hasMoreElements() )		buf.append( e.nextElement().toString() + " " );	return buf.toString() + "</SERVER>";}}final class StaticScopeThunk implements AbstractThunk {AbstractMember templateMember;public StaticScopeThunk (AbstractMember member) {	templateMember = member;}public AbstractMember evaluate (AbstractMemberContainer scope) throws MendelException {	AbstractMember memberClone = templateMember.shallowCopy();	memberClone.setStaticScope(scope);	return memberClone;}}