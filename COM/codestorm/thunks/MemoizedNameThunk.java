/** * A MemoizedNameThunk looks up a name in a scope then memoizes the relative path. ***/package COM.codestorm.thunks;	import COM.codestorm.builders.*;import COM.codestorm.mendel.*;class MemoizedNameThunk implements AbstractThunk {ThunkChainEnvelope			memoThunkChain;String						key;AbstractMemberContainer		origStaticMember;public MemoizedNameThunk (String s, AbstractMemberContainer staticMember) {	key = s;	memoThunkChain = null;	origStaticMember = staticMember;}public AbstractMember evaluate (AbstractMemberContainer scope) throws MendelException {	AbstractMember foundMember = this.lookup(scope);	AbstractMemberContainer scopeContainer = (AbstractMemberContainer) memoThunkChain.evaluate(scope).getStaticScope(MissingThrower.NoContainerThrower);	try {		if ( foundMember.getStaticScope(MissingThrower.NoContainerThrower) == scopeContainer )			return foundMember;		else return ManufacturedMember.childOf((AbstractMemberContainer) foundMember,scopeContainer);	}	catch (NoContainerException nce) {		return foundMember;	}}protected AbstractMember lookup (AbstractMemberContainer scope) throws MendelException {	if ( memoThunkChain == null ) {				MemberByNameThunk	lookupThunk = new MemberByNameThunk(key);		boolean justaThisThunk = true;		memoThunkChain = new ThunkChainEnvelope(new ThisThunk());				for (;;) {			try {				boolean containerNameMatches;				AbstractMemberContainer testContainer = (AbstractMemberContainer) memoThunkChain.evaluate(origStaticMember);				try {					containerNameMatches = testContainer.getProperty(AbstractMember.keyName).equals(key);				}				catch (NoPropertyException npe) {					containerNameMatches = false;				}				if ( containerNameMatches ) {					if ( scope == origStaticMember ) {						return testContainer;					} else {						return memoThunkChain.evaluate(scope);					}				}				else {					AbstractMember foundMember = (AbstractMemberContainer) lookupThunk.evaluate(testContainer);					if ( scope != origStaticMember ) {						try {							testContainer = (AbstractMemberContainer) memoThunkChain.evaluate(scope);							foundMember = lookupThunk.evaluate(testContainer);						}						catch (MemberNotFoundException mfe) {							throw new NoMemberException("\""+key+"\" unexpectedly missing from container "+MendelDebugger.nameOf(testContainer));						}					}					memoThunkChain.append(lookupThunk);					return foundMember;				}			}			catch (NoContainerException nce) {				throw new NoMemberException("Not enough containers in chain to evaluate \""+key+"\" in scope "+MendelDebugger.nameOf(scope));			}			catch (NoMemberException mnfe) {				boolean containerNameMatches;				AbstractMemberContainer testContainer = (AbstractMemberContainer) memoThunkChain.evaluate(origStaticMember);				try {					containerNameMatches = testContainer.getProperty(AbstractMember.keyName).equals(key);				}				catch (NoPropertyException npe) {					containerNameMatches = false;				}				if ( containerNameMatches ) {					return testContainer;				}				else if ( memoThunkChain.size() == 1 && justaThisThunk ) {					memoThunkChain = new ThunkChainEnvelope(new ContainerThunk());					justaThisThunk = false;				} else memoThunkChain.append(new ContainerThunk());			}		}	}	else return memoThunkChain.evaluate(scope);}public String toString () {	return key;}}