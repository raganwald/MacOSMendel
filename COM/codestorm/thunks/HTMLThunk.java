/** * * @author Reginald Braithwaite-Lee ***/package COM.codestorm.thunks;import COM.codestorm.builders.*;import COM.codestorm.mendel.*;import COM.objectspace.jgl.*;import java.util.*;import java.io.*;public class HTMLThunk implements AbstractThunk {protected Sequence thunkSequence;protected final static String lispEscape = "__LISP__";protected final static String openLisp = "<SERVER>"; // future enhancement--support <SERVER LANGUAGE="MendelLISP">protected final static int openLispLength = openLisp.length();protected final static String closeLisp = "</SERVER>";protected final static int closeLispLength = closeLisp.length();/** * evaluate catenates all of the elements in the sequence. * HTMLThunks evaluate everything with themseleves as the * scope. In that sense they are like StaticThunks. * * @param scope the scope to evaluate the HTMLThunk in. * @see ScriptThunk#evaluate ***/public AbstractMember evaluate (AbstractMemberContainer scope) throws MendelException {	TextMember bufTextMember = new TextMember();	Enumeration e = thunkSequence.elements();	while ( e.hasMoreElements() ) {		AbstractMember evaluatedMember  = ((AbstractThunk) e.nextElement()).evaluate(scope);		while ( !(evaluatedMember instanceof AbstractMember) && (evaluatedMember instanceof AbstractThunk) )			evaluatedMember = ((AbstractThunk) evaluatedMember).evaluate(scope);		bufTextMember.append(evaluatedMember.asText());	}	return bufTextMember;}/** * builds an empty HTMLThunk. * * @return the HTMLContainer ***/public HTMLThunk () {	thunkSequence = new SList();}/** * builds an HTMLThunk from an HTML expression. * * @param String	stringRep the HTML code * @return the HTMLContainer * @exception MendelException a syntax error of some sort. ***/public HTMLThunk (String stringRep) throws MendelException {	this();	this.append(stringRep);}protected void append (String str) throws MendelException {	String stringRep = new String(str);	// first, are there HTML tags?		if ( stringRep.startsWith(Defaults.openHTML) ) {		try {//			String tagString = stringRep.substring(Defaults.openHTML.length(),stringRep.indexOf(Defaults.closeTag)+1);//			if ( tagString.length() > 1 ) {//				try {//					MemberTokenizer mt = new MemberTokenizer(new StringBufferInputStream(tagString));//					mt.parseProperties(this);//				}//				catch (IOException ioe) {//				}//			}			stringRep = stringRep.substring(stringRep.indexOf(Defaults.closeTag)+1);		}		catch (IndexOutOfBoundsException ioobe) {			throw new MendelException(Defaults.openHTML+" without "+Defaults.closeTag);		}		try {			stringRep = stringRep.substring(0,stringRep.lastIndexOf(Defaults.closeHTML));		}		catch (IndexOutOfBoundsException ioobe) {			throw new MendelException(Defaults.openHTML+Defaults.closeTag+" without "+Defaults.closeHTML);		}	}	// second,  locate and remove <SERVER>É</SERVER> segments	int nextStart = stringRep.indexOf(openLisp);	int nextStop = 0;		while ( nextStart >= 0 ) {		int balance = 1;		int cursor = nextStart + openLispLength;				do {			int tempNextStart = stringRep.indexOf(openLisp,cursor);			nextStop = stringRep.indexOf(closeLisp,cursor);						if ( nextStop < 0 ) // no more stops??				throw new MendelException("<SERVER> without matching </SERVER>");			if ( tempNextStart < 0 ) { // there is no further start				--balance;				cursor = nextStop + closeLispLength;			}			else if ( tempNextStart > nextStop ) { // next start is *after* next stop				--balance;				cursor = nextStop + closeLispLength;			}			else {				++balance;				cursor = tempNextStart + openLispLength;			}		} while ( balance > 0 );				if ( nextStart > 0 )			thunkSequence.pushBack(new HTMLString(stringRep.substring(0,nextStart)));				thunkSequence.pushBack(new ScriptThunk(stringRep.substring(nextStart+openLispLength,cursor-closeLispLength),null));				stringRep = stringRep.substring(cursor);		nextStart = stringRep.indexOf(openLisp);		nextStop = 0;			}		if ( stringRep.length() > 0 )		thunkSequence.pushBack(new HTMLString(stringRep));}public String debugString () {	StringBuffer buf = new StringBuffer(Defaults.openHTML+Defaults.closeTag);	Enumeration e = thunkSequence.elements();	while ( e.hasMoreElements() )		buf.append( e.nextElement().toString() );	return buf.toString() + Defaults.closeHTML;}public boolean isEmpty () throws MendelException {	return ( thunkSequence.size() == 0 );}}